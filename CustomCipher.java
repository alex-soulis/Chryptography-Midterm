/**
 * CustomCipher implements a custom symmetric encryption algorithm based on
 * an 8-round Substitutionâ€“Permutation Network (SPN).
 *
 * <p>
 * The cipher is designed for educational purposes and demonstrates the
 * fundamental concepts of modern block ciphers, including:
 * </p>
 * <ul>
 *   <li>Substitution (confusion)</li>
 *   <li>Permutation via P-box (diffusion)</li>
 *   <li>Multiple rounds</li>
 *   <li>Externally generated subkeys (modular design)</li>
 * </ul>
 *
 * <p>
 * IMPORTANT:
 * This class does NOT generate subkeys. It assumes that an external class
 * (e.g. SubkeyGenerator) provides exactly 8 round keys.
 * </p>
 *
 * Encryption process per round:
 * <ol>
 *   <li>Substitution using the round key</li>
 *   <li>P-box permutation on blocks of 8 characters</li>
 * </ol>
 *
 * Decryption performs the inverse operations in reverse round order.
 */
public class CustomCipher {

    /** Number of encryption/decryption rounds */
    private static final int ROUNDS = 8;

    /**
     * The array of externally generated round keys.
     * Must contain exactly 8 elements.
     */
    private final String[] roundKeys;

    /** Block size for the P-box permutation */
    private static final int BLOCK_SIZE = 8;

    /**
     * Fixed P-box permutation.
     * Each index represents the new position of the character.
     */
    private static final int[] PBOX = {2, 5, 1, 7, 4, 0, 3, 6};

    /**
     * Inverse permutation of the P-box, used during decryption.
     */
    private static final int[] PBOX_INV = new int[BLOCK_SIZE];

    /**
     * Static initialization block for computing the inverse P-box.
     */
    static {
        for (int i = 0; i < BLOCK_SIZE; i++) {
            PBOX_INV[PBOX[i]] = i;
        }
    }

    /**
     * Constructs a CustomCipher object using externally supplied round keys.
     *
     * @param roundKeys an array of exactly 8 subkeys generated by an external component
     * @throws IllegalArgumentException if the array is null or does not contain 8 keys
     */
    public CustomCipher(String[] roundKeys) {
        if (roundKeys == null || roundKeys.length != ROUNDS) {
            throw new IllegalArgumentException("Exactly 8 round keys are required.");
        }
        this.roundKeys = roundKeys;
    }

    /**
     * Encrypts a plaintext string using the 8-round SPN algorithm.
     *
     * @param plaintext the text to encrypt
     * @return the resulting ciphertext
     */
    public String encrypt(String plaintext) {
        String result = plaintext;

        for (int round = 0; round < ROUNDS; round++) {
            result = substitution(result, roundKeys[round]);
            result = permutation(result);
        }

        return result;
    }

    /**
     * Decrypts a ciphertext string using the inverse of the 8-round SPN algorithm.
     *
     * @param ciphertext the encrypted text
     * @return the original plaintext
     */
    public String decrypt(String ciphertext) {
        String result = ciphertext;

        for (int round = ROUNDS - 1; round >= 0; round--) {
            result = reversePermutation(result);
            result = reverseSubstitution(result, roundKeys[round]);
        }

        return result;
    }

    /**
     * Applies the substitution step using additive character transformation.
     *
     * @param text the input text
     * @param key the round key
     * @return substituted text
     */
    private String substitution(String text, String key) {
        StringBuilder sb = new StringBuilder();
        int keyLen = key.length();

        for (int i = 0; i < text.length(); i++) {
            char plain = text.charAt(i);
            char k = key.charAt(i % keyLen);
            sb.append((char) (plain + k));
        }

        return sb.toString();
    }

    /**
     * Applies the inverse substitution used during decryption.
     *
     * @param text the substituted text
     * @param key the round key
     * @return original text
     */
    private String reverseSubstitution(String text, String key) {
        StringBuilder sb = new StringBuilder();
        int keyLen = key.length();

        for (int i = 0; i < text.length(); i++) {
            char cipher = text.charAt(i);
            char k = key.charAt(i % keyLen);
            sb.append((char) (cipher - k));
        }

        return sb.toString();
    }

    /**
     * Applies the P-box permutation on blocks of 8 characters.
     *
     * @param text the text to permute
     * @return permuted text
     */
    private String permutation(String text) {
        char[] in = text.toCharArray();
        char[] out = new char[in.length];

        int offset = 0;

        while (offset < in.length) {
            int blockLen = Math.min(BLOCK_SIZE, in.length - offset);

            if (blockLen < BLOCK_SIZE) {
                for (int j = 0; j < blockLen; j++)
                    out[offset + j] = in[offset + j];
            } else {
                for (int j = 0; j < BLOCK_SIZE; j++)
                    out[offset + PBOX[j]] = in[offset + j];
            }

            offset += blockLen;
        }

        return new String(out);
    }

    /**
     * Applies the inverse P-box permutation.
     *
     * @param text the permuted text
     * @return original order restored text
     */
    private String reversePermutation(String text) {
        char[] in = text.toCharArray();
        char[] out = new char[in.length];

        int offset = 0;

        while (offset < in.length) {
            int blockLen = Math.min(BLOCK_SIZE, in.length - offset);

            if (blockLen < BLOCK_SIZE) {
                for (int j = 0; j < blockLen; j++)
                    out[offset + j] = in[offset + j];
            } else {
                for (int j = 0; j < BLOCK_SIZE; j++)
                    out[offset + PBOX_INV[j]] = in[offset + j];
            }

            offset += blockLen;
        }

        return new String(out);
    }
}
